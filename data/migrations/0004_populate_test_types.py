# Generated by Django X.Y on YYYY-MM-DD HH:MM
# -*- coding: utf-8 -*-
from django.db import migrations

# Список базовых типов тестов для добавления
TEST_TYPES_DATA = [
    {'name': 'Общий анализ крови', 'description': 'Complete Blood Count (CBC)'},
    {'name': 'Биохимический анализ крови', 'description': 'Clinical Biochemistry Panel'},
    {'name': 'Коагулограмма', 'description': 'Coagulation Profile'},
    {'name': 'Общий анализ мочи', 'description': 'Urinalysis'},
    {'name': 'Гормоны щитовидной железы', 'description': 'Thyroid Hormonal Panel'},
    {'name': 'Липидный профиль', 'description': 'Lipid Profile'},
    {'name': 'Иммунологический анализ', 'description': 'Immunology / Autoimmune Panel'},
    {'name': 'Инфекционная серология', 'description': 'Infectious Disease Serology'},
    {'name': 'Онкомаркеры', 'description': 'Tumor Markers'},
    # Добавьте другие общие типы тестов по мере необходимости
    {'name': 'Другое', 'description': 'Other/Miscellaneous Tests'},
]

def populate_test_type_data(apps, schema_editor):
    """
    Заполняет модель TestType данными из списка TEST_TYPES_DATA.
    """
    TestType = apps.get_model('data', 'TestType') # Получаем историческую модель
    db_alias = schema_editor.connection.alias

    existing_names = set(TestType.objects.using(db_alias).values_list('name', flat=True))

    test_types_to_create = []
    for item in TEST_TYPES_DATA:
        if item['name'] not in existing_names:
            test_types_to_create.append(
                TestType(
                    name=item['name'],
                    description=item.get('description', '')
                )
            )
            existing_names.add(item['name'])
        else:
            print(f"TestType '{item['name']}' already exists, skipping.")

    if test_types_to_create:
        print(f"\nCreating {len(test_types_to_create)} new test types...")
        TestType.objects.using(db_alias).bulk_create(test_types_to_create)
        print("TestType data population complete.")
    else:
        print("\nNo new test types to create.")

def reverse_code(apps, schema_editor):
    """
    Код для отката миграции (удаление добавленных типов).
    """
    TestType = apps.get_model('data', 'TestType')
    db_alias = schema_editor.connection.alias
    names_to_delete = [item['name'] for item in TEST_TYPES_DATA]
    TestType.objects.using(db_alias).filter(name__in=names_to_delete).delete()
    print(f"\nDeleted test types added by this migration.")
    # pass # Или просто ничего не делаем при откате

class Migration(migrations.Migration):

    # Указываем зависимость от предыдущей миграции в приложении 'data'
    # Замените '0003_populate_analytes' на имя вашей *последней* миграции для 'data'
    # перед созданием этой миграции.
    dependencies = [
        ('data', '0003_populate_analytes'), # <-- УБЕДИТЕСЬ, ЧТО ЭТО ИМЯ ПРЕДЫДУЩЕЙ МИГРАЦИИ
    ]

    operations = [
        migrations.RunPython(populate_test_type_data, reverse_code=reverse_code),
    ]